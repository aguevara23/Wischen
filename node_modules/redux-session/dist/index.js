'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Returns the appropriate adapter based on the given adapter
 * argument from options.
 *
 * @param  {*} adapter
 * @return {Object}
 */
function getAdapter (adapters, adapter) {
  // if the adapter is an object that implements the needed methods,
  // quickly return it
  if (typeof adapter === 'object' && adapter.get && adapter.set && adapter.has && adapter.clear) {
    return adapter;
  }

  // if no adapter provided, assume one
  if ( ! adapter) {
    adapter = (window.localStorage ? 'localStorage' : 'cookieStorage');
  }

  // use one of the provides adapters
  if (adapters[adapter]) {
    return adapters[adapter];
  }

  throw new Error('A valid storage adapter could not be found!  You can use one of the default adapters by setting adapter to "localStorage" or "cookieStorage".  Or, if you need something custom, you can provide a simple adapter object with set(), get(), has() and clear() methods.');
}

/**
 * Returns a new object that omits the keys in the given array.
 *
 * @param  {Array} keys
 * @param  {Object} obj
 * @return {Object}
 */
function shallowOmit (keys, obj) {
  var j = {};
  for (var k$1 in obj) {
    if (keys.indexOf(k$1) === -1) {
      j[k$1] = obj[k$1];
    }
  }
  return j;
}

/**
 * Returns a throttled method that can only be invoked once per the
 * time duration specified.
 *
 * @param  {Function} fn
 * @param  {Number} wait
 */
function debounce (fn, wait) {
  var timeout, dirty;

  return function () {
    if (timeout) {
      dirty = true;
      return;
    }

    timeout = setTimeout(function () {
      clearTimeout(timeout);
      timeout = null;
      if (dirty) {
        fn.apply(this, arguments);
        dirty = false;
      }
    }, wait);

    fn.apply(this, arguments);
  }
}

var localStorageAdapter = {

  /**
   * Stores the given data as a string at the given namespace.
   *
   * @param  {String}
   * @param  {*}
   */
  set: function set (name, data) {
    window.localStorage.setItem(name + '.root', JSON.stringify(data));
  },

  /**
   * Returns the data stored at the given namespace.
   *
   * @param  {String} name
   * @return {*}
   */
  get: function get (name) {
    return JSON.parse(window.localStorage.getItem(name + '.root'));
  },

  /**
   * Returns true if data is stored at the given namespace.
   *
   * @param  {String} name
   * @return {Boolean}
   */
  has: function has (name) {
    return !!window.localStorage.getItem(name + '.root');
  },

  /**
   * Removes the item stored at the given namespace.
   *
   * @param  {String} name
   */
  clear: function clear (name) {
    window.localStorage.removeItem(name + '.root');
  }

};

function notImplementedWarning () {
  console.warn('[redux-session] The cookieStorage adapter has not yet been implemented!  This adapter is merely a stub for functionality that will come soon.  This means that none of your session data has been saved.');
}

var cookieStorageAdapter = {

  set: function set (name, data, opts) {
    notImplementedWarning();
  },

  get: function get (name) {
    notImplementedWarning();
  },

  has: function has (name) {
    notImplementedWarning();
  },

  clear: function clear (name) {
    notImplementedWarning();
  }

};

/**
 * Valid namespace definition
 * @type {RegExp}
 */
var VALID_NS = /[a-zA-Z0-9\.]/;

/**
 * Options that should not be passed to check()
 * @type {Array}
 */
var OMITTED_OPTS = [
  'adapter',
  'onLoad',
  'selectState',
  'clearStorage'
];

/**
 * Default options for middleware.
 * @type {Object}
 */
var defaultOpts = {
  throttle: 2000,
  silent: false,
  onLoad: function onLoad (storedState, dispatch) {
    dispatch({ type: 'LOAD_STORED_STATE', storedState: storedState });
  },
  selectState: function selectState (state) {
    return state;
  },
  clearStorage: function clearStorage (action) {
    return (action.type === 'CLEAR_STORED_STATE');
  }
};

/**
 * The built-in adapters that are provided by this library.
 * @type {Object}
 */
var adapters = {
  localStorage: localStorageAdapter,
  cookieStorage: cookieStorageAdapter
};

/**
 * Returns a new middleware function for Redux using the given
 * parameters.
 *
 * @param  {Object} opts
 * @return {Function}
 */
function createSession (opts) {
  if ( opts === void 0 ) opts = {};

  // define our default options
  opts = Object.assign({}, defaultOpts, opts);

  // get the namespace from opts
  var ns = opts.ns;

  // get a partial subset of options to pass to adapter methods
  var _opts = shallowOmit(OMITTED_OPTS, opts);

  // validate the given namespace
  if (typeof ns !== 'string' || ! VALID_NS.test(ns)) {
    throw new Error('You must provide a valid namespace "ns" for your project!');
  }

  // determine the storage adapter
  var storage = getAdapter(adapters, opts.adapter);

  // allow storage to check our options for config issues
  if (typeof storage.check === 'function') {
    storage.check(_opts);
  }

  return function (ref) {
    var getState = ref.getState;
    var dispatch = ref.dispatch;

    // the function that will update storage
    var updateStorage = (opts.debounce || debounce)(function () {
      var state = opts.selectState(getState());
      storage.set(ns, state, _opts);
    }, opts.throttle);

    // dispatch action to hydrate state (if any)
    if (storage.has(ns, _opts)) {
      opts.onLoad(storage.get(ns, _opts), dispatch);
    }

    return function (next) { return function (action) {
      // dispatch the action
      var result = next(action);

      // flag for whether storage should be cleared.
      var shouldClearStorage = opts.clearStorage(action);

      // clear storage if needed
      if (shouldClearStorage) { storage.clear(ns, _opts); }

      // otherwise, update storage with the latest
      else { updateStorage(); }

      return result;
    }; }
  }
}

exports.adapters = adapters;
exports.createSession = createSession;
